-- Consecutively Rising Temperture
-- Get the number of days that you observe rising temperature
-- find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.
-- I want to find the date that has higher temp than yesterday
-- # LEAD LAG : Row Operation
-- # order by is important with LEAD and LAG

"""
[DATA]

| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |  
DROP TABLE IF EXISTS temp.rising_temperature ;
CREATE TABLE IF NOT EXISTS temp.rising_temperature (
    Id INT
    ,RecordDate date
    ,temperature int
  )
  ;


insert overwrite table temp.rising_temperature
select * from 
(
select stack(
    10,                 
1,'2015-01-01',10,
2,'2015-01-02',25,
3,'2015-01-03',20,
4,'2015-01-04',30,
5,'2015-01-05',20,
6,'2015-01-06',30, 
7,'2015-01-07',40,
8,'2015-01-08',50, 
9,'2015-01-09',60,
10,'2015-01-10',30    

    ) 
) s;
"""

-- This is LEAD and LAG
select
    id
    ,recorddate
    ,temperature
    ,lag(temperature) over ( -- lag gives me one ahead
        order by recorddate asc
        ) prev_date
from temp.rising_temperature
having temperature > prev_date  -- current row bigger than one before me
-- if I do not provide partition, it will be over the entire thing
-- providing order by guarantees the order that I apply lead and lag

# STEP 1
select
    id
    ,recorddate
    ,temperature
    ,lag(temperature) over (
        order by recorddate asc
        ) prev_date
     -- putting the previous day tempterature right next to today's
    ,if(temperature > lag(temperature) over (
                        order by recorddate asc
                        ), True, False
                        ) warmer 
     -- use the window function result to compare with original row
     -- if today's temp is higher, True
     -- This becomes the commonality that will eventually be used for conditional row numbering to compare with original row numbering
from temp.rising_temperature


# STEP 2.
select
    t1.id - row_number() over () as consecutive_group -- the consecutive group number
    ,count(t1.id - row_number() over ()) over (       -- how long the consecutive group number lasts
        partition by t1.id - row_number() over ()     -- partition by is the groupby num generated by subtraction of row numberings
        ) consecutive_group_count
    ,t1.recorddate
    ,t1.temperature
    ,t1.prev_date
from (
    select
        id
        ,recorddate
        ,temperature
        ,lag(temperature) over (
            order by recorddate asc
            ) prev_date
        ,if(temperature > lag(temperature) over (
                            order by recorddate asc
                            ), True, False) warmer 
    from temp.rising_temperature
    ) t1
where warmer = True

# Step 3
--find dates that had more than 3 consecutive temperature increase
select 
    *
from (
    select
        t1.id - row_number() over () as consecutive_group
        ,count(t1.id - row_number() over ()) over (
            partition by t1.id - row_number() over ()
            ) consecutive_group_count
        ,t1.recorddate
        ,t1.temperature
        ,t1.prev_date
    from (
        select
            id
            ,recorddate
            ,temperature
            ,lag(temperature) over (
                order by recorddate asc
                ) prev_date
            ,if(temperature > lag(temperature) over (
                                order by recorddate asc
                                ), True, False) warmer 
        from temp.rising_temperature
        ) t1
    where warmer = True
) t2
where t2.consecutive_group_count > 3



-----------
